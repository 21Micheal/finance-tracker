import { __commonJS } from "./chunk-Cas2H8Ax.js";
import { require_react } from "./react-Lhyjpgc9.js";

//#region node_modules/react-plaid-link/dist/index.umd.js
var require_index_umd = /* @__PURE__ */ __commonJS({ "node_modules/react-plaid-link/dist/index.umd.js": ((exports, module) => {
	(function(global, factory) {
		typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require_react()) : typeof define === "function" && define.amd ? define(["exports", "react"], factory) : (global = global || self, factory(global.PlaidLink = {}, global.React));
	})(exports, (function(exports$1, React) {
		var React__default = "default" in React ? React["default"] : React;
		function ownKeys(object, enumerableOnly) {
			var keys = Object.keys(object);
			if (Object.getOwnPropertySymbols) {
				var symbols = Object.getOwnPropertySymbols(object);
				enumerableOnly && (symbols = symbols.filter(function(sym) {
					return Object.getOwnPropertyDescriptor(object, sym).enumerable;
				})), keys.push.apply(keys, symbols);
			}
			return keys;
		}
		function _objectSpread2(target) {
			for (var i = 1; i < arguments.length; i++) {
				var source = null != arguments[i] ? arguments[i] : {};
				i % 2 ? ownKeys(Object(source), !0).forEach(function(key) {
					_defineProperty(target, key, source[key]);
				}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
					Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
				});
			}
			return target;
		}
		function _defineProperty(obj, key, value) {
			if (key in obj) Object.defineProperty(obj, key, {
				value,
				enumerable: true,
				configurable: true,
				writable: true
			});
			else obj[key] = value;
			return obj;
		}
		function _objectWithoutPropertiesLoose(source, excluded) {
			if (source == null) return {};
			var target = {};
			var sourceKeys = Object.keys(source);
			var key, i;
			for (i = 0; i < sourceKeys.length; i++) {
				key = sourceKeys[i];
				if (excluded.indexOf(key) >= 0) continue;
				target[key] = source[key];
			}
			return target;
		}
		function _objectWithoutProperties(source, excluded) {
			if (source == null) return {};
			var target = _objectWithoutPropertiesLoose(source, excluded);
			var key, i;
			if (Object.getOwnPropertySymbols) {
				var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
				for (i = 0; i < sourceSymbolKeys.length; i++) {
					key = sourceSymbolKeys[i];
					if (excluded.indexOf(key) >= 0) continue;
					if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
					target[key] = source[key];
				}
			}
			return target;
		}
		function _slicedToArray(arr, i) {
			return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
		}
		function _arrayWithHoles(arr) {
			if (Array.isArray(arr)) return arr;
		}
		function _iterableToArrayLimit(arr, i) {
			var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
			if (_i == null) return;
			var _arr = [];
			var _n = true;
			var _d = false;
			var _s, _e;
			try {
				for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
					_arr.push(_s.value);
					if (i && _arr.length === i) break;
				}
			} catch (err) {
				_d = true;
				_e = err;
			} finally {
				try {
					if (!_n && _i["return"] != null) _i["return"]();
				} finally {
					if (_d) throw _e;
				}
			}
			return _arr;
		}
		function _unsupportedIterableToArray(o, minLen) {
			if (!o) return;
			if (typeof o === "string") return _arrayLikeToArray(o, minLen);
			var n = Object.prototype.toString.call(o).slice(8, -1);
			if (n === "Object" && o.constructor) n = o.constructor.name;
			if (n === "Map" || n === "Set") return Array.from(o);
			if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
		}
		function _arrayLikeToArray(arr, len) {
			if (len == null || len > arr.length) len = arr.length;
			for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
			return arr2;
		}
		function _nonIterableRest() {
			throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
		}
		var _excluded = ["src", "checkForExisting"];
		var scripts = {};
		var checkExisting = function checkExisting$1(src) {
			var existing = document.querySelector("script[src=\"".concat(src, "\"]"));
			if (existing) return scripts[src] = {
				loading: false,
				error: null,
				scriptEl: existing
			};
		};
		var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
		function useScript(_ref) {
			var src = _ref.src, _ref$checkForExisting = _ref.checkForExisting, checkForExisting = _ref$checkForExisting === void 0 ? false : _ref$checkForExisting, attributes = _objectWithoutProperties(_ref, _excluded);
			var status = src ? scripts[src] : void 0;
			if (!status && checkForExisting && src && isBrowser) status = checkExisting(src);
			var _useState = React.useState(status ? status.loading : Boolean(src)), _useState2 = _slicedToArray(_useState, 2), loading = _useState2[0], setLoading = _useState2[1];
			var _useState3 = React.useState(status ? status.error : null), _useState4 = _slicedToArray(_useState3, 2), error = _useState4[0], setError = _useState4[1];
			var _useState5 = React.useState(false), _useState6 = _slicedToArray(_useState5, 2), scriptLoaded = _useState6[0], setScriptLoaded = _useState6[1];
			React.useEffect(function() {
				if (!isBrowser || !src || scriptLoaded || error) return;
				status = scripts[src];
				if (!status && checkForExisting) status = checkExisting(src);
				var scriptEl;
				if (status) scriptEl = status.scriptEl;
				else {
					scriptEl = document.createElement("script");
					scriptEl.src = src;
					Object.keys(attributes).forEach(function(key) {
						if (scriptEl[key] === void 0) scriptEl.setAttribute(key, attributes[key]);
						else scriptEl[key] = attributes[key];
					});
					status = scripts[src] = {
						loading: true,
						error: null,
						scriptEl
					};
				}
				var handleLoad = function handleLoad$1() {
					if (status) status.loading = false;
					setLoading(false);
					setScriptLoaded(true);
				};
				var handleError = function handleError$1(error$1) {
					if (status) status.error = error$1;
					setError(error$1);
				};
				scriptEl.addEventListener("load", handleLoad);
				scriptEl.addEventListener("error", handleError);
				document.body.appendChild(scriptEl);
				return function() {
					scriptEl.removeEventListener("load", handleLoad);
					scriptEl.removeEventListener("error", handleError);
					if (status && status.loading) {
						scriptEl.remove();
						delete scripts[src];
					}
				};
			}, [src]);
			return [loading, error];
		}
		var renameKeyInObject = function renameKeyInObject$1(o, oldKey, newKey) {
			var newObject = {};
			delete Object.assign(newObject, o, _defineProperty({}, newKey, o[oldKey]))[oldKey];
			return newObject;
		};
		/**
		* Wrap link handler creation and instance to clean up iframe via destroy() method
		*/
		var createPlaidHandler = function createPlaidHandler$1(config, creator) {
			var state = {
				plaid: null,
				open: false,
				onExitCallback: null
			};
			if (typeof window === "undefined" || !window.Plaid) throw new Error("Plaid not loaded");
			state.plaid = creator(_objectSpread2(_objectSpread2({}, config), {}, { onExit: function onExit(error, metadata) {
				state.open = false;
				config.onExit && config.onExit(error, metadata);
				state.onExitCallback && state.onExitCallback();
			} }));
			return {
				open: function open() {
					if (!state.plaid) return;
					state.open = true;
					state.onExitCallback = null;
					state.plaid.open();
				},
				submit: function submit(data) {
					if (!state.plaid) return;
					state.plaid.submit(data);
				},
				exit: function exit(exitOptions, callback) {
					if (!state.open || !state.plaid) {
						callback && callback();
						return;
					}
					state.onExitCallback = callback;
					state.plaid.exit(exitOptions);
					if (exitOptions && exitOptions.force) state.open = false;
				},
				destroy: function destroy() {
					if (!state.plaid) return;
					state.plaid.destroy();
					state.plaid = null;
				}
			};
		};
		var createPlaid = function createPlaid$1(options, creator) {
			var config = renameKeyInObject(options, "publicKey", "key");
			return createPlaidHandler(config, creator);
		};
		var PLAID_LINK_STABLE_URL = "https://cdn.plaid.com/link/v2/stable/link-initialize.js";
		var noop = function noop$1() {};
		/**
		* This hook loads Plaid script and manages the Plaid Link creation for you.
		* You get easy open & exit methods to call and loading & error states.
		*
		* This will destroy the Plaid UI on un-mounting so it's up to you to be
		* graceful to the user.
		*
		* A new Plaid instance is created every time the token and products options change.
		* It's up to you to prevent unnecessary re-creations on re-render.
		*/
		var usePlaidLink = function usePlaidLink$1(options) {
			var _useScript = useScript({
				src: PLAID_LINK_STABLE_URL,
				checkForExisting: true
			}), _useScript2 = _slicedToArray(_useScript, 2), loading = _useScript2[0], error = _useScript2[1];
			var _useState = React.useState(null), _useState2 = _slicedToArray(_useState, 2), plaid = _useState2[0], setPlaid = _useState2[1];
			var _useState3 = React.useState(false), _useState4 = _slicedToArray(_useState3, 2), iframeLoaded = _useState4[0], setIframeLoaded = _useState4[1];
			var products = (options.product || []).slice().sort().join(",");
			React.useEffect(function() {
				if (loading) return;
				if (!options.token && !options.publicKey && !options.receivedRedirectUri) return;
				if (error || !window.Plaid) {
					console.error("Error loading Plaid", error);
					return;
				}
				if (plaid != null) plaid.exit({ force: true }, function() {
					return plaid.destroy();
				});
				var next = createPlaid(_objectSpread2(_objectSpread2({}, options), {}, { onLoad: function onLoad() {
					setIframeLoaded(true);
					options.onLoad && options.onLoad();
				} }), window.Plaid.create);
				setPlaid(next);
				return function() {
					return next.exit({ force: true }, function() {
						return next.destroy();
					});
				};
			}, [
				loading,
				error,
				options.publicKey,
				options.token,
				products
			]);
			return {
				error,
				ready: plaid != null && (!loading || iframeLoaded),
				submit: plaid ? plaid.submit : noop,
				exit: plaid ? plaid.exit : noop,
				open: plaid ? plaid.open : function openNoOp() {
					if (!options.token) console.warn("react-plaid-link: You cannot call open() without a valid token supplied to usePlaidLink. This is a no-op.");
				}
			};
		};
		var _excluded$1 = [
			"children",
			"style",
			"className"
		];
		var PlaidLink = function PlaidLink$1(props) {
			var children = props.children, style = props.style, className = props.className, config = _objectWithoutProperties(props, _excluded$1);
			var _usePlaidLink = usePlaidLink(_objectSpread2({}, config)), error = _usePlaidLink.error, open = _usePlaidLink.open;
			return /* @__PURE__ */ React__default.createElement("button", {
				disabled: Boolean(error),
				type: "button",
				className,
				style: _objectSpread2({
					padding: "6px 4px",
					outline: "none",
					background: "#FFFFFF",
					border: "2px solid #F1F1F1",
					borderRadius: "4px"
				}, style),
				onClick: function onClick() {
					return open();
				}
			}, children);
		};
		PlaidLink.displayName = "PlaidLink";
		var PlaidEmbeddedLink = function PlaidEmbeddedLink$1(props) {
			var style = props.style, className = props.className, onSuccess = props.onSuccess, onExit = props.onExit, onLoad = props.onLoad, onEvent = props.onEvent, token = props.token, receivedRedirectUri = props.receivedRedirectUri;
			var config = React.useMemo(function() {
				return {
					onSuccess,
					onExit,
					onLoad,
					onEvent,
					token,
					receivedRedirectUri
				};
			}, [
				onSuccess,
				onExit,
				onLoad,
				onEvent,
				token,
				receivedRedirectUri
			]);
			var _useScript = useScript({
				src: PLAID_LINK_STABLE_URL,
				checkForExisting: true
			}), _useScript2 = _slicedToArray(_useScript, 2), loading = _useScript2[0], error = _useScript2[1];
			var embeddedLinkTarget = React.useRef(null);
			React.useEffect(function() {
				if (loading) return;
				if (error || !window.Plaid) {
					console.error("Error loading Plaid", error);
					return;
				}
				if (config.token == null || config.token == "") {
					console.error("A token is required to initialize embedded Plaid Link");
					return;
				}
				var _window$Plaid$createE = window.Plaid.createEmbedded(_objectSpread2({}, config), embeddedLinkTarget.current), destroy = _window$Plaid$createE.destroy;
				return function() {
					destroy();
				};
			}, [
				loading,
				error,
				config,
				embeddedLinkTarget
			]);
			return /* @__PURE__ */ React__default.createElement("div", {
				style,
				className,
				ref: embeddedLinkTarget
			});
		};
		(function(PlaidLinkStableEvent) {
			PlaidLinkStableEvent["OPEN"] = "OPEN";
			PlaidLinkStableEvent["EXIT"] = "EXIT";
			PlaidLinkStableEvent["HANDOFF"] = "HANDOFF";
			PlaidLinkStableEvent["SELECT_INSTITUTION"] = "SELECT_INSTITUTION";
			PlaidLinkStableEvent["ERROR"] = "ERROR";
			PlaidLinkStableEvent["BANK_INCOME_INSIGHTS_COMPLETED"] = "BANK_INCOME_INSIGHTS_COMPLETED";
			PlaidLinkStableEvent["IDENTITY_VERIFICATION_PASS_SESSION"] = "IDENTITY_VERIFICATION_PASS_SESSION";
			PlaidLinkStableEvent["IDENTITY_VERIFICATION_FAIL_SESSION"] = "IDENTITY_VERIFICATION_FAIL_SESSION";
		})(exports$1.PlaidLinkStableEvent || (exports$1.PlaidLinkStableEvent = {}));
		exports$1.PlaidEmbeddedLink = PlaidEmbeddedLink;
		exports$1.PlaidLink = PlaidLink;
		exports$1.usePlaidLink = usePlaidLink;
		Object.defineProperty(exports$1, "__esModule", { value: true });
	}));
}) });

//#endregion
export default require_index_umd();

//# sourceMappingURL=react-plaid-link.js.map